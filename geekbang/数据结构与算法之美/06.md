# 链表：如何实现LRU缓存淘汰算法

缓存淘汰策略

* 先进先出策略FIFO
* 最少使用策略LFU
* 最近最少使用策略LRU

分类

* 单链表
* 双向链表
* 循环链表

> 链表的插入和删除的时间复杂度为O(1),具体下还有先决条件。

对链表操作的具体分析

* 删除
  - 删除结点中”节点值等于某个给定值“的节点。（删除时间复杂度为o(1)、查找时间复杂度为o(n)）
  _ 删除给定指针指向的节点。
    * 单向链表，需要知道前驱节点，遍历查找到pre->netx==find。（删除时间复杂度为o(1)、查找时间复杂为o(n)）
    * 双向链表。（删除为o(1),查找pre时间也为o(1))
* 插入分析类型如上，分单向和双向进行分析

* 数组、链表
  * 数组，需要连续内存空间
  * 链表，不需要连续内存空间

## 链表实现LRU缓存淘汰算法

* 数据结构
  - 单链表
  - 有序（越靠近链表尾部的节点是越早之前访问过的）
* 缓存数据（访问、淘汰）规则
  - 访问数据无
    * 缓存数据是否满
      - 满了，将尾部数据删除、访问数据插入链表头部
      - 没满，直接将访问数据插入
  - 访问数据有
    * 将原先节点删除并插入到链表头部
## 数组实现LRU缓存淘汰算法

* 数据结构
  - 数组
  - 