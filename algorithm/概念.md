# 算法简介
* 算法运行时间用大O表示法表示。
* 算法运行时间是从其增速的角度度量的。
# 选择排序
## 链表和数组(队列)
&nbsp;|数组|链表
----|----|---
读取   |O(1)|O(n)
插入   |O(n)|O(1)
删除   |O(n)|O(1)
选择排序:时间复杂度O(n^2);空间复杂度O(1);
```
    function selectSort(arr){
        let len = constLen = arr.length;
        while(len > 0){
            for(let i = 0; i < len; i++){
                let compar = constLen - len + i;
                if(arr[compar] < arr[constLen - len]){
                    let midVal = arr[compar];
                    arr[compar] = arr[constLen - len];
                    arr[constLen - len] = midVal;
                }
            }
            len--;
        }
        return arr;
    }
```
冒泡排序:时间复杂度O(n^2);空间复杂度O(1);
```
    function bubbleSort(arr){
        let len = constLen = arr.length;
        while(len > 0){
            for(let i = 0; i < constLen - 1; i++){
                if(((!arr[i]) || arr[i] > arr[i + 1])){
                    let midVal = arr[i+1];
                    arr[i+1] = arr[i];
                    arr[i] = midVal;
                }
            }
            len--;
        }
        return arr;
    }
```
# 递归
* 递归--每个递归函数都有两个部分：基线部分和递归条件，递归条件是指函数调用自己时的条件。基线部分是指不再调用自身时，避免无限循环的条件。
* 栈--栈是一种简单的数据结构，后进先出。
* 栈有两种操作压入和弹出。
二分递归(升序)查找:
```
    function binarySearch(arr, findVal){
        let endIndex = arr.length, startIndex = 0;
        return (function recursion(start, end){
            let midIndex = parseInt((start + end)/2);
            if(arr[midIndex] === findVal) return midIndex;
            if(midIndex === start || midIndex === end) return -1;
            if(arr[midIndex] > findVal) return recursion(start, midIndex);
            if(arr[midIndex] < findVal) return recursion(midIndex, end);
        })(startIndex, endIndex) 
    }
```
# 快速排序
递归形式:找出矩形以正方形均匀分块的最大正方形。
```
    function maxCube(height, width){
    	let remainder,divisor,dividend;
    	if(height > width){
    		divisor = width;
    		dividend = height;
    	}else{
    		divisor = height;
    		dividend = width;
    	}
    	remainder = dividend%divisor;
    	if(remainder === 0) return divisor;
    	return maxCube(remainder,divisor);
    }
```
递归形式:数组求和。
```
    function sumArr(arr){
        if(arr.length === 0) return 0;
        return arr.pop() + sumArr(arr);
    }
```
递归形式:快速排序时间复杂度(最坏情况为O(n^2)，排序数组为有序的)
```
    function quickSort(arr){
    	let len = arr.length,leftArr=[],rightArr=[],normVal=arr[parseInt(Math.random()*len)];
    	if(len < 2){
    		return arr;
    	}
    	for(let i = 1;i < len; i++){
    		if(arr[i] >= normVal){
    			rightArr.push(arr[i]);
    		}else{
    			leftArr.push(arr[i]);
            }		
    	}
    	return quickSort(leftArr).concat([normVal]).concat(quickSort(rightArr));
    }
```
# 散列表
* 散列函数:传入查找参数能返回指定的值。
* 散列表（数据结构）:包含散列函数和数组的一种数据结构，包含额外的逻辑的数据结构；散列表能快速查找到键，时间复杂度O(1)
* 在JavaScript中散列表数据结构实现为对象这种数据结构。
## 散列表适用于
* 仿真映射关系
* 防止重复
* 缓存/记住数据，以免服务器通过处理再次生成他们。
## 散列表如何避免冲突。
* 较低的填装因子
* 良好的散列函数
# 广度优先搜索
## 图是什么
图是一种节点与节点相连的数据额结构。直接相连表示两个节点有关系
## 广度优先搜索
广度优先搜索算法是作用于图这种数据结构的搜索算法，能帮助我们解决的问题：
* 查找图中两节点的相连关系。
* 两个节点的最短路径
* 队列:是一种先进先出的数据结构。
## 图在代码的实现
可以通过散列表来实现对应关系。散列表的键与值能形成一一对应的关系，两个节点通过指向的关系来表示关系，如果是单向指向的话是有向图，无指向的话是无向图
。
```
    let amongPeople = {
        "Aob":{
                name:"a",
                parents:{
                    father:{
                        name:"Aa"
                    },
                    mother:{
                        name:"aa"
                    }
                }
            },
            "Bob":{
                name:"b",
                parents:{
                    father:{
                        name:"Bb",
                        parents:{
                            father:{
                                name:"BBb"
                            },
                            mother:{
                                name:"bBb"
                            }
                        }
                    },
                    mother:{
                        name:"bb",
                        parents:{
                            father:{
                                name:"Bbb"
                            },
                            mother:{
                                name:"bbb"
                            }
                        }
                    }
                }
            },
            "Cob":{
                name:"c",
                parents:{
                    father:{
                        name:"Cc"
                    },
                    mother:{
                        name:"cc"
                    }
                }
            },
        }
```
* 拓扑排序是有向图中节点依赖关系的排序，根据图能创建一个有序列表。例如：b依赖a，b只能在a的后面。
* 树是一种特殊的图，树的指向不能从子层指向父层及以上。
广度优先搜索:
```
    function findPath(map, find){
        let record = [],queue=[];
        for(let i = 0; i < Object.keys(map).length;i++){
            queue.push(map[Object.keys(map)[i]]);
        }
        for(let j = 0; j < queue.length; j++){ 
            let currentVal = queue[j].name;
            if(record.indexOf(currentVal) ===-1){
                if(currentVal === find){
                    return true;
                }else if(queue[j].parents){
                    for(let i = 0; i < Object.keys(queue[j].parents).length;i++){
                        queue.push(queue[j].parents[Object.keys(queue[j].parents)[i]]);
                    }
                    record.push(currentVal);
                }
            }
        }
        return false;
    }
```
运行时间为:O (V + E )， 其中V 为顶点（vertice） 数， E 为边数。
# 狄克斯特拉算法
> 狄克斯特拉算法能够在加权图中找到前往X的最短路径;图中的环导致算法不管用。

添加图的结构图、优化广度优先搜索的算法。