[原文链接](http://www.dailichun.com/2018/03/12/whenyouenteraurl.html)
# 大纲
* 对知识体系进行一次预评级
* 为什么说知识体系如此重要？
* 梳理主干流程
* 从浏览器接收url到开启网络请求线程

    * 多进程的浏览器
    * 多线程的浏览器内核
    * 解析URL
    * 网络请求都是单独的线程
    * 更多
* 开启网络线程到发出一个完整的http请求

    * DNS查询到ip地址
    * tcp/ip请求
    * 五层因特网协议栈
* 从服务器接收到请求到对应后台接受到请求
    * 负载均衡
    * 后台的处理
* 后台和前台的http交互

    * http报文结构
    * cookie以及优化
    * gzip压缩
    * 长连接和短连接
    * http2.0
    * http
* 单独拎出来的缓存问题，http的缓存

    * 强缓存和弱缓存
    * 缓存头部简述
    * 头部的区别
* 解析页面流程

    * 流程简述
    * HTML解析，构建DOM
    * 生成css规则
    * 构建渲染树
    * 渲染
    * 简单层和复合层
    * Chrome中的调试
    * 资源外链的下载
    * loaded和domcontentloaded
* CSS的可视化格式模型

    * 包含块(Containing Block)
    * 控制框(Controlling Box)
    * BFC(Block Formatting Context)
    * IFC(Inline Formatting Context)
    * 其它
* JS引擎解析过程

    * JS解释阶段
    * JS的预处理阶段
    * JS的执行阶段
    * 回收机制
* 其它
* 总结
# 为什么说知识体系如此重要
**总结**：知识体系化后，对一个问题能有浅到深的解答，会更全面，可以不断的往事情的本质挖掘。
## 例子
* getComputedStyle
    * getComputedStyle返回元素最终计算出的css属性值，可以通过window.getComputedStyle和document.defaultView.getComputedStyle调用。
    * 可以举出获取元素高度和背景色，来推断出输出css属性值为当前元素计算的值。
    * getComputedStyle会引起回流，因为它需要获取祖先节点的一些信息来进行计算，产生回流引起性能问题。offsetXXX，scrollXXX，clientXXX，currentStyle等等都能产生回流问题。
* visibility: hidden 和 display: none的区别
    * 前者隐藏占据位置，后者隐藏不占据位置。
    * display由于隐藏后不占据位置，所以造成dom树的改变，会引起回流，代价比加大。
    * 当一个页面某个元素经常需要切换display时如何优化，一般会用复合层优化，或者要求低一点用absolute让其脱离普通文档流也行。然后可以将话题引到普通文档流，absolute文档流，复合图层的区别，
    * 再进一步可以描述下浏览器渲染原理以及复合图层和普通图层的绘制区别（复合图层单独分配资源，独立绘制，性能提升，但是不能过多，还有隐式合成等等）
## 前端向知识的重点
* 核心/基础知识：浏览器模型、渲染原理、JS解析过程、JS运行机制
* 重点知识，往往每一块都是一个知识点，而且这些知识点都很重要，譬如http相关，web安全相关，跨域处理等
* 拓展知识，这一块可能更多的是了解，稍微实践过，但是认识上可能没有上面那么深刻，譬如五层因特网协议栈，hybrid模式，移动原生开发，后台相关等等（当然，在不同领域，可能有某些知识就上升到重点知识层次了，譬如hybrid开发时，懂原生开发是很重要的）
# 梳理主干流程
对于这道题，我们先梳理问题的主干，再填充细节。

    1.从浏览器接受url到开启网络请求线程（这部分可以展开浏览器的机制以及进程和线程之间的关系）
    2.开启网络线程到发出一个完整到http请求（这部分有DNS查询、tcp/ip请求、五层因特网协议栈等知识）
    3.从服务器接受到请求到对应后台接受到请求（这部分有负载均衡、安全拦截、后台内部处理等）
    4.后台和前台到http交互（这部分包括http头部、响应码、报文结构、cookice等知识）
    5.单独拎出来到缓存问题，http到缓存（http缓存头部、etag、catch-control等）
    6.浏览器收到http数据包的解析流程（解析html-词法分析生成DOM树、解析css生成css规则树、合并成rander树、然后layout&&painting渲染、复合图层的合成、GPU绘制、外链资源的处理、loaded和domcontentloaded等）
    7.CSS的可视化格式模型（元素等渲染规则，如：包含块、控制框、BFC、IFC等概念）;
    8.JS引擎解析过程（JS解释阶段，预处理阶段,JS执行过程-JS生成上下文、VO、作用域链、回收机制等）
    9.其它（拓展不同的知识模块，跨域问题、web安全、hybrid模式等）
# 浏览器接受URL到开启网络请求线程
内容:浏览器进程/线程模型,JS的运行机制。
## 多进程浏览器模型
进程包括：浏览器主控进程、插件进程、GPU、Tab页进程

* browser进程：浏览器的主进程（负责协调、主控），只有一个
* 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建
* GPU进程：最多一个，用于3D绘制
* 浏览器渲染进程（内核）：默认每个Tab页一个进程，互不影响，主要控制页面渲染，脚本执行，事件处理（有时候会优化，如多个空白tab会合并成一个进程）
## 多线程等的浏览器内核
每个tab页可以看作浏览器内核进程，这个进程是多线程的，有几大类子线程
* GUI线程
* JS引擎线程
* 事件触发线程
* 定时器线程
* 网络请求线程
由此可以看出JS引擎线程是浏览器内核进程中的一个线程，这也就知道为什么JS引擎是单线程的了。
## 解析URL