# 异步操作 #
## 1、单线程模型 ##
javascript引擎为单线程模型：[单线程概念](https://wangdoc.com/javascript/async/general.html#%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B "概念")
## 2、同步任务和异步任务 ##
理解：同步任务为主进程的任务，异步任务为挂起任务。

javascript执行程序时有同步任务执行和异步任务执行的区别：[同步任务、异步任务概念](https://wangdoc.com/javascript/async/general.html#%E5%90%8C%E6%AD%A5%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1)
## 3、任务队列和事件循环 ##
执行程序有正在执行的主进程，还有任务队列；当主进程执行完毕时，会执行任务队列里可以执行的任务：
[任务队列、时间循环概念](https://wangdoc.com/javascript/async/general.html#%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF)

## 4、异步操作的模式 ##
#### 4.1回调函数 ####
1.f1中回调f2
<pre>
<code>
function f1(callback){ 
	// ...  
	callback();
}
function f2(){ 
	// ...
}

f1(f2);
</code>
</pre>
> 回调函数的优点是简单、容易理解和实现，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（coupling），使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数。

#### 4.2事件监听 ####
事件监听如**概念3中的时间循环**取决于事件是否满足条件进而执行。

监听事件可以指定多个回调函数，可以“去耦合”，便于实现模块化；但是由于监听事件是事件驱动，所以容易让代码变的不清晰。
#### 4.3发布/订阅 ####
[发布/订阅jQuery的实现：](https://gist.github.com/661855)
<pre>
<code>
jQuery.subscirbe('done',f2);

function f1(){
	setTimeout(function(){
		//....
		jQuery.publish('done');
	})
}
//取消订阅

jQuery.unsubscribe('done',f2)
</code>
</pre>
“发布/订阅”又称“观察者模式”--f1执行完向jQuery发布done信号，从而f2执行，f2执行后，可以取消订阅。
## 5、异步操作的流程控制 ##
#### 5.1串行执行 ####
<pre>
<code>
function async(val , callback){
	setTimeout(function(){
		callback(val);
	},1000)
}
function final(val){
	console.log(val);
}
function series(i){
	if(i < 7){
		i++;
		async(i , function(i){
			return series(i);
		})
	}else{
		return final(i);
	}
}
series(1);
</code>
</pre>
这是一个串行执行的异步任务，会过7秒再执行final()函数。控制程序的执行。
#### 5.2并行执行 ####
<pre>
<code>

function async(val , callback){
	setTimeout(function(){
		callback(val);
	},1000)
}
function final(val){
	console.log(val);
}
for(var i=0 ; i<7 ; i++){
	async(i , function(i){
		if(i === 6){
			final(i);
		}
	})
}
</code>
</pre>
异步任务同时执行，在执行完成后执行final;
#### 5.3并行和串行的结合 ####
并行和串行的结合，也就是控制每次执行n个异步任务。
<pre>
<code>
var items = [ 1, 2, 3, 4, 5, 6 ];
var results = [];
var running = 0;
var limit = 2;

function async(arg, callback) {
  console.log('参数为 ' + arg +' , 1秒后返回结果');
  setTimeout(function () { callback(arg * 2); }, 1000);
}

function final(value) {
  console.log('完成: ', value);
}

function launcher() {
  while(running < limit && items.length > 0) {
    var item = items.shift();
    async(item, function(result) {
      results.push(result);
      running--;
      if(items.length > 0) {
        launcher();
      } else if(running == 0) {
        final(results);
      }
    });
    running++;
  }
}

launcher();
</code>
</pre>
2018/9/28 23:53:48 

----------

