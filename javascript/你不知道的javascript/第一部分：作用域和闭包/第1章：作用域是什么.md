# 1.1 编译原理 #
javascript代码会在执行前进行编译（通常在执行前）。

编译语言的源代码会在执行前经历三个步骤，通常称为“编译”：

#### 1.分词/词法分析
分词(tokenizing)和词法分析(Lexing)之间的区别是非常微妙、晦涩的， 主要差异在于词法单元的识别是通过有状态还是无状态的方式进行的。简 单来说，如果词法单元生成器在判断 a 是一个独立的词法单元还是其他词法 单元的一部分时，调用的是有状态的解析规则，那么这个过程就被称为词法 分析。

#### 2.解析/语法分析
这个过程是将词法单元流(数组)转换成一个由元素逐级嵌套所组成的代表了程序语法 结构的树。这个树被称为“抽象语法树”(Abstract Syntax Tree，AST)。
var a = 2; 的抽象语法树中可能会有一个叫作 VariableDeclaration 的顶级节点，接下 来是一个叫作 Identifier(它的值是 a)的子节点，以及一个叫作 AssignmentExpression 的子节点。AssignmentExpression 节点有一个叫作 NumericLiteral(它的值是 2)的子 节点。
#### 3.代码生成
将 AST 转换为可执行代码的过程称被称为代码生成。这个过程与语言、目标平台等息 息相关。
抛开具体细节，简单来说就是有某种方法可以将 var a = 2; 的 AST 转化为一组机器指 令，用来创建一个叫作 a 的变量(包括分配内存等)，并将一个值储存在 a 中。

# 1.2 理解作用域 #
## 1.2.1 名词解释 ##

	1.引擎：从头到尾负责整个javascript程序的编译及执行过程。（v8引擎）
	2.编译器：引擎的好朋友，负责语法分析及代码生成。
	3.作用域：引擎的好朋友，负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行代码对这些标识符的访问权限。
## 1.2.2 var a = 2; 运行过程 ##
引擎在这里会有两个步骤：

	1、遇到var a，编译器会询问作用域是否已经有一个该名称的变量存在同一个作用域的集合中。如果有，忽略该声明，继续编译。如果否，在当前作用域的集合
	中声明一个新的变量，并命名为a。
	2、编译器会为引擎生成运行时所需的代码，这些代码用来处理a = 2这个赋值操作。引擎运行时会首先询问作用域， 在当前的作用域集合中是否存在一个叫作
	 a 的变量。 如果是， 引擎就会使用这个变量； 如果否， 引擎会继续查找该变量
## 1.2.3 LHS查询、RHS查询##
上面的例子在编译器在编译过程的第二步中生成了代码， 引擎执行它时， 会通过查找变量 a 来判断它是
否已声明过。 查找的过程由作用域进行协助， 但是引擎执行怎样的查找， 会影响最终的查
找结果。

**变量出现在赋值操作的左侧时进行 LHS 查询， 出现在非左侧时进行 RHS 查询。**

RHS 查询与简单地查找某个变量的值别无二致， 而 LHS 查询则是试图找到变量的容器本身， 从而可以对其赋值。

概念：**赋值操作的目标是谁(LHS);谁是赋值操作的源头(RHS)**
## 1.2.4 引擎与作用域的交流。 ##
<pre>
function foo(a) {
	console.log( a ); // 2
} 
foo( 2 );
</pre>
1.执行foo(2)时，引擎会向作用域找foo的RHS引用，然后如果是函数的值的话，再执行；

2.执行foo函数时有a = 2的操作，引擎会向作用域要a进行LHS引用；作用域发现编译器把它声明为foo的一个形参，引擎知道后将2赋值给a。

3.在执行console.log(a)时会执行RHS引用，来查询a的值。

4.console.log()这个函数的执行与foo()函数执行步骤一致。
## 1.2.5 练习 ##
<pre>
function foo(a){
	var b = a;
	return a + b;
}
var c = foo(2);
</pre>
**LHS查询、RHS查询:**
	
	1.引擎执行 var c = foo(2)时;执行一次var c的LHS查询，找到foo(2)。
	2.foo进行RHS查询为一个函数并执行foo(2),形参a进行LHS查询，找到2，并赋值给a。
	3.var b = a；对a进行RHS查询，b进行LHS查询。
	4.执行return a + b；语句是分别对a、b进行了RHS查询。
所以LHS执行了3次；RHS执行了4次。
# 1.3 作用域嵌套 #
作用域是根据名称查找变量一套规则，通常有多个作用域要兼顾。

引擎在当前作用域无法找到某个变量时，会向外层嵌套的作用域查找，直到找到该变量或到达最外层的作用域为止。
# 1.4 异常 #
RHS 查询在所有嵌套的作用域中遍寻不到所需的变量， 引擎就会抛出 ReferenceError
异常。RHS 查询找到了一个变量， 对这个变量进行不合理的操作，会抛出TypeError异常。

LHS 查询时， 如果在顶层（全局作用域） 中也无法找到目标变量，
全局作用域中就会创建一个具有该名称的变量， 并将其返还给引擎， 前提是程序运行在非
“严格模式” 下。严格模式下也会抛出ReferenceError异常。

ReferenceError 同作用域判别失败相关， 而 TypeError 则代表作用域判别成功了， 但是对
结果的操作是非法或不合理的。
# 1.5 小结 #
	1.作用域是一套规则， 用于确定在何处以及如何查找变量（标识符）。
	2.如果查找的目的是对变量进行赋值， 那么就会使用 LHS 查询;赋值操作符会导致 LHS 查询。 
	＝操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。
	3.如果目的是获取变量的值， 就会使用 RHS 查询。